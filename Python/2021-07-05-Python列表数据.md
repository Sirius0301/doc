# Python 列表数据

## Key Points

- Python 中一切都是对象。对象可以有**状态**（属性或值）和**行为**（方法）
- Python设置了4个内置的数据结构，分别是**列表**，**元组**，**字典**，**集合**
  - **列表**：有序的可变对象集合
  - **元组**：有序的不可变对象集合
  - **字典**：无序的键/值对集合
  - **列表**：无序的唯一对象集合

## 4个内置的数据结构

列表，元组，字典，列表

### 列表

list: **有序的可变对象集合**

Python的列表是动态的，因为它们可以根据需要拓展和收缩。使用列表存储任何对象之前不需要预声明列表的大小

- 列表中每个元素从0开始
- 列表是可变的，可以在任何时间通过增加、删除或修改对象来修改列表

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711103919794.png" alt="image-20210711103919794" style="zoom:50%;" />

#### 创建列表

```py
prices = []
temps = [ 32.0, 212.0, 0.0, 81.6, 100.0, 45.3 ]
words = [ 'hello', 'world']
car_details = [ 'Toyota', 'RAV4', 2.2, 60807 ]
everything = [ prices, temps, words, car_details ]
odds_and_ends = [ [1, 2, 3], ['a', 'b', 'c'] ]
```

#### 使用列表

```py
vowels = ['a', 'e', 'i', 'o', 'u']
word = input('Provide a word to search for vowels:')
found = []
for letter in word:
    if letter in vowels:
        if letter not in found:
            found.append(letter)

for vowels in found:
    print(vowels)

```

#### 常用列表方法

- **append**: 在运行时，将对象增加到现有列表
- **pop**: 取一个可选的索引值作为参数，根据对象的索引值从现有列表删除和返回一个对象
- **remove**: 取一个对象值作为唯一的参数， 从列表中删除指定数据值的第一次出现
- **insert**: 取一个索引值和对象作为参数，将一个对象插入到现有列表中指定索引值的前面
- **extend**: 取一个对象列表作为唯一参数，接受第二个列表，并将其中各个对象增加到现有列表

```py
phrase = "Don't panic!"
plist = list(phrase)
print(phrase)
print(plist)
# ['D', 'o', 'n', "'", 't', ' ', 'p', 'a', 'n', 'i', 'c', '!']

# list.[append, insert, remove, pop, extend]
# Only use the above 5 methods to create a new string "on tap"
# for i in range(4):
#     plist.pop()
# plist.pop(0)
# plist.insert(2, plist.pop(4))
# plist.remove("'")
# plist.insert(4, plist.pop())

# Only use [start:stop:step] to create a new string "on tap"
plist = plist[1:8]
plist.pop(2)
plist.insert(3, plist.pop(2))
plist.extend([plist.pop(), plist.pop()])
new_phrase = ''.join(plist)
print(plist)
print(new_phrase)

```

#### 对象复制

赋值操作并不能把一个列表复制到另一个列表，只会让赋值操作符两边的对象共享该列表的引用

列表提供**copy**方法，它会完成真正的复制

#### 列表中括号记法

列表方法会改变一个列表的状态，而使用中括号标记法和切片（通常）不会改变列表的状态

- Python对索引位置编号是从0开始，而且同样使用**中括号记法**来访问列表中的对象
- Python对索引位置编号支持负索引值，从-1开始
- Python列表还认识**start**（开始值）, **stop**（结束值）,**step**（步长值）
  - **start**: 允许你控制范围从哪里开始，默认值为0
  - **stop**: 允许你控制范围何时结束，默认去列表允许的最大值
  - **step**: 允许你控制范围如何生成，默认值为1

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711112705533.png" alt="image-20210711112705533" style="zoom:50%;" />

```python
>>>letters = 'Hi,Python.'
>>>plist = list(letters)
>>>plist
# ['H', 'i', ',', 'P', 'y', 't', 'h', 'o', 'n', '.']
>>> plist[:]
# ['H', 'i', ',', 'P', 'y', 't', 'h', 'o', 'n', '.']
>>>len(plist)
# 10
>>>plist[1:10:2]
# ['i', 'P', 't', 'o', '.']
>>>plist[:10]
# ['H', 'i', ',', 'P', 'y', 't', 'h', 'o', 'n', '.']
>>>plist[3:]
# ['P', 'y', 't', 'h', 'o', 'n', '.']
>>>plist[::3]
# ['H', 'P', 'h', '.']
```



### 字典

dictionary(dict): 无序数据结构，**无序的键/值对集合**

在字典中每个唯一键有一个与之关联的的值，字典可以包含多个键/值对。与键关联的值可以是任意对象。

- 字典存储键值对
- 字典是无序且可变的
- 字典不能依赖解释器所用的内部顺序

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711105016651.png" alt="image-20210711105016651" style="zoom:50%;" />

> 在`C++`和`Java`中，字典被称为“映射”，而perl和ruby把它们叫做“散列”

#### 创建字典

```python
found = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}
person3={'Name':'Ford Prefect', 'Gender':'Male', 'Occupation':'Researcher', 'Home Planet':'Betelgeuse Seven'}
person3['Age'] = 33
```

#### 使用字典

字典使用了高度优化的散列算法，使解释器能快速地访问与宇哥键关联的值（而不论你的字典有多大）

> 大多数Python程序员使用`dict`描述字典，如果按最基本的形式，字典就是一个有两列任意多行的表

我们通常迭代处理字典，使用for循环遍历字典

```python
for k in found:
  print(k, 'is', found[k])
```

#### 字典常用方法

- `sorted`：指定输出时的字典顺序
- `items`：迭代处理字典
- `setdefault`：保证使用一个键之前总会将它初始化为一个起始值，避免KeyError

```python
for k in sorted(found):
  print(k, 'is', found[k])
```

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711132807485.png" alt="image-20210711132807485" style="zoom:50%;" />

```python
for k, v in sorted(found.items()):
  print(k, 'is', v)
```

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711132931752.png" alt="image-20210711132931752" style="zoom:50%;" />

```python
vowels = ['a', 'e', 'i', 'o', 'u']
word = input("Provide a word to search for vowels: ")
# found = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}
found = {}
for letter in word:
    if letter in vowels:
        # if letter in found:
        #     found[letter] += 1
        # else:
        #     found[letter] = 1
        found.setdefault(letter, 0)
        found[letter] += 1

for k, v in sorted(found.items()):
    print(k, 'was found', v, 'time(s).')

```

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711133027036.png" alt="image-20210711133027036" style="zoom:50%;" />

#### 字典注意事项

- 可以把字典想成是一个行集，每一行值包含两列。第一列存储一个键，第二列存储一个值
- 各行称为一个键值对，可以扩展为包含任意多个键/值对。与列表类似，字典可以根据需要拓展和收缩
- 字典很容易发现：字典用大括号包围，每个键/值对间用一个冒号分隔，各个键与相应的值之间用一个冒号分隔
- 字典不会维持插入时的顺序
- 访问字典中的数据要使用中括号，将键放在中括号里可以访问与这个键关联的值
- Python中需要指定一个布尔值的时候，可以使用`True`或 `False`，这是解释器提供的常量值，首字母必须大写。
- 默认的，所有字典都是无序的，如果需要在输出中对字典排序，需要使用`sorted`内置函数
- `items`方法允许按行迭代处理一个字典。一次迭代中，`items`方法会向for循环返回下一个键和它的关联值
- 如果试图访问字典中一个不存在的值，会导致一个KeyError。出现KeyError时，程序会由于运行时错误崩溃
- 访问一个键之前，可以使用`setdefault`方法确保每个键都有一个关联值来避免KeyError

### 集合

set: 一种避免重复的数据结构，**无序的唯一对象集合**

- 集合不允许有重复的对象
- 集合还允许你完成并集，交集和差集操作

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711105932469.png" alt="image-20210711105932469" style="zoom:50%;" />

#### 创建集合

很容易在代码中找出集合：这是一个对象结合，对象相互之间用逗号分隔，包围在大括号里

```python
vowels = {'a', 'e', 'i', 'o', 'u'}
vowels2 = set('aeiou')
```

 #### 使用集合

```python
vowels = set('aeiou')
word = input('Provide a word to search for vowels:')
found = vowels.intersection(set(word))
for vowel in found:
    print(vowel)

```

#### 集合常用方法

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711214534167.png" alt="image-20210711214534167" style="zoom:50%;" />

- `union` : 并集

  ```python
  vowels = set('aeiou')
  word = 'python'
  u = vowels.union(set(word))
  sorted(u)
  # ['a', 'e', 'h', 'i', 'n', 'o', 'p', 't', 'u', 'y']
  ```

  > `union` 将一个集合与另一个集合合并，再把合并结果赋值给一个新集合`u`. 转换中会删除所有重复对象

- `difference` : 差集

  ```python
  u = vowels.difference(set(word))
  sorted(u)
  # ['a', 'e', 'i', 'u']
  ```

  > `difference` 会告诉你哪些元素只在一个集合中而不在另一个集合中

- `intersection` : 交集

  ```python
  u = vowels.intersection(set(word))
  sorted(u)
  # ['o']
  ```

  > `intersection` 会取一个集合中的对象，与另一个集合中的对象进行比较，然后报告找到的共同对象

#### 集合注意事项

- Python 的集合不允许有重复
- 与字典类似，集合用大括号包围，不过集合没有键值对。集合中每个唯一对象之间用一个逗号分隔
- 同样与字典类似，集合不维持插入顺序（不过可以用`sorted`函数排序）
- 可以向`set`函数传递任何序列，由这个序列中的对象创建一个元素集合（去除所有重复）
- 集合提供了大量内置功能，包括完成并集、差集和交集的方法

### 元组

tuple: **有序的不可变对象集合**

通常可以把元组想成一个常量列表，一旦像元组赋对象，任何情况下这个元组都不能改变

<img src="https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210711104218684.png" alt="image-20210711104218684" style="zoom:50%;" />

> 假设你要保证没有副作用，程序中的一些数据永远不会变。使用元组可以避免不必要的开销，并保证没有烦人的数据副作用

#### 创建元组

元组用小括号包围

```python
vowels = ( 'a', 'e', 'i', 'o', 'u')

```



#### 使用元组



#### 元组常用方法



#### 元组注意事项




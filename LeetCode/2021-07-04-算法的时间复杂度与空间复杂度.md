## 算法的时间与空间复杂度

算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

那么我们应该如何去衡量不同算法之间的优劣呢？

主要`算法的执行时间`和所需要`占用的存储空间` 两个方面衡量，即 「时间复杂度」(Time Complexity)  和「空间复杂度」(Space Complexity). 都通过 **大O符号**来表示。算法时间复杂度记为 T(n)=O(?)，空间复杂度记为 S(n)=O(?)。

## 时间复杂度 (Time Complexity)

在[计算机科学](https://zh.wikipedia.org/wiki/计算机科学)中，[算法](https://zh.wikipedia.org/wiki/算法)的**时间复杂度**（Time complexity）是一个[函数](https://zh.wikipedia.org/wiki/函数)，它定性描述该算法的运行时间。这是一个代表算法输入值的[字符串](https://zh.wikipedia.org/wiki/字符串)的长度的函数。时间复杂度常用[大O符号](https://zh.wikipedia.org/wiki/大O符号)表述，不包括这个函数的低阶项和首项系数。使用这种方式时，时间复杂度可被称为是[渐近](https://zh.wikipedia.org/wiki/渐近分析)的，亦即考察输入值大小趋近无穷时的情况。例如，如果一个算法对于任何大小为 *n* （必須比 *n0* 大）的输入，它至多需要 5*n*3 + 3*n* 的时间运行完毕，那么它的渐近时间复杂度是 O(*n*3)。

为了计算时间复杂度，我们通常会计算算法的操作单元数量，每个单元执行的时间都是相同的。因此，总运行时间和算法的操作单元数量最多相差一个常量系数。

相同大小的不同输入值可能造成算法的执行时间不同。因此通常使用算法的[最壞情況複雜度](https://zh.wikipedia.org/w/index.php?title=最壞情況複雜度&action=edit&redlink=1)，記為 ***T\*(\*n\*)**， 定义为任何大小的输入所需要的最大执行时间。

简单来说，就是**寻找输入n与操作单元执行数量x 之间的数学关系**，详细见下文解释。

### 常见时间复杂度 ( T(n) = O(?) ) 

![image-20210704214953529](https://gitee.com/sirius_wang_wf/typora/raw/master/images/image-20210704214953529.png)

| No   | O(?)          | 场景           | 说明                          |
| ---- | ------------- | -------------- | ----------------------------- |
| 1    | **O(1)**      | 常数复杂度     | Constant Complexity           |
| 2    | **O(log n)**  | 对数复杂度     | Logarithmic Complexity        |
| 3    | **O(n)**      | 线性时间复杂度 | Linear Complexity             |
| 4    | **O(nlog n)** | 线性对数复杂度 | Linear Logarithmic Complexity |
| 5    | **O(n^2)**    | 平方复杂度     | N square Complexity           |
| 6    | **O(n^3)**    | 立方复杂度     | N cubic Complexity            |
| 7    | **O(2^n)**    | 指数复杂度     | Exponential Growth Complexity |
| 8    | **O(n!)**     | 阶乘复杂度     | Factorial Complexity          |

### O(1)

常数(Constant)阶，最低的时间复杂度，耗时与输入数据无关，无论输入数据增大多少倍，耗时都不变。哈希算法就是典型的 **O(1)** 时间复杂度。

```java
int n = 9; 
system.println("Hello, sirius");
system.println("Hello, sirius");
```

其中输入`n=3`， 执行次数为`x=3`, 两者并无关联。因此 `T(n) = O(1)`

> 输出 “Hello, Sirius” 2次

### O(log n)

对数(Logarithmic)阶，比常数阶大。

```java
int i = 1;
int n = 9;
while(i < n){
  i = i*2; 
	system.println("Hello, sirius");
}
```

假设循环x次之后，i >=n, 循环结束。`n = 2^x` 也就是`x=log2^n``

> 输出 “Hello, Sirius” 3次

### O(n)

线性(Linear)关系, 比对数阶稍大。

```java
int n = 9;
for(int i = 0; i < n; i++){
  system.println("Hello, Sirius");
}
```

`x=n`次之后，循环结束。`x=n``

> 输出 “Hello, Sirius” 9次

### O(nlogn)

```java
int n = 9;
for(int m=1; m<n; m++){
  int i = 1;
	while(i < n){
 	  i = i*2;
    system.println("Hello, Sirius");
	}
}
```

线性阶内嵌套对数阶。内部循环log2^n 次，外部循环n次。`

> 输出 “Hello, Sirius” 27次

### O(n^2)

```java
int n = 9;
for(int i = 0; i < n; i++){
  for(int m = 0; m < n; m++){
  	system.println("Hello, Sirius");
  }
}
```

线性阶内嵌套一层线性阶。内部循环n次数，外部循环n次数

> 输出 “Hello, Sirius” 81次

### O(n^3)

### 

```java
int n = 5;
for(int i = 0; i < n; i++){
  for(int m = 0; m < n; m++){
    for(int m = 0; m < n; m++){
  		system.println("Hello, Sirius");
  	}
  }
}
```

线性阶套娃，O(n^k) 同理。

> 输出 “Hello, Sirius” 729次

### O(2^n)

> ToDo

### O(n!)

> ToDo

## 空间复杂度 (Space Complexity)

算法执行所需要的临时空间随变量n的大小变化而变化。

常用空间复杂度：

| No   | O(?)       | 场景       |
| ---- | ---------- | ---------- |
| 1    | **O(1)**   | 常数复杂度 |
| 2    | **O(n)**   | 一维数组   |
| 3    | **O(n^2)** | 二维数组   |



## 参考资料

- [时间复杂度-维基百科](https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)

- [空间复杂度- MBA智库](https://wiki.mbalib.com/wiki/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
- [算法时间复杂度](https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/07/01.html)

